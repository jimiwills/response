.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::MaxQuant::Evidence::Statistics 3"
.TH Bio::MaxQuant::Evidence::Statistics 3 "2014-02-12" "perl v5.16.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::MaxQuant::Evidence::Statistics \- Additional statistics on your SILAC evidence
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Read/convert your evidence file to a more rapidly processable format,
and perform various operations and statistics across/between multiple
experiments.  Supports multidimensional experiments with replicate
analyses.
.PP
.Vb 1
\&    use Bio::MaxQuant::Evidence::Statistics;
\&
\&    my $foo = Bio::MaxQuant::Evidence::Statistics\->new();
\&    
\&    # get the essential data from an evidence file
\&    $foo\->parseEssentials(filename=>$evidencePath);
\&
\&    # store the essentials for later
\&        $foo\->writeEssentials(filename=>$essentialsPath);
\&
\&        # laod previously stored essentials
\&        $foo\->readEssentials(filename=>$essentialsPath);
.Ve
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "new"
.IX Subsection "new"
Create a new object:
.PP
.Vb 1
\&    my $foo = Bio::MaxQuant::Evidence::Statistics\->new();
.Ve
.SS "clearCache"
.IX Subsection "clearCache"
Some stuff is cached.  This can lead to massive memory usage.  It's a good idea to 
clear the cache every now and then.
.SS "parseEssentials(%options)"
.IX Subsection "parseEssentials(%options)"
Reads the essential data from an evidence file.  Evidence files
for large analyses can be very big and take a long time to process,
to we only read what's necessary, and can save this for convenience
and speed too, using \fIwriteEssentials()\fR.
.PP
The data are stored by Protein group IDs, i.e. one entry per protein
group.  Other data stored here are:
.IP "id" 4
.IX Item "id"
.PD 0
.IP "Protein group IDs" 4
.IX Item "Protein group IDs"
.IP "Modified  \*(-- is this actually the right name??" 4
.IX Item "Modified   is this actually the right name??"
.IP "Leading Proteins" 4
.IX Item "Leading Proteins"
.IP "Experiment" 4
.IX Item "Experiment"
.IP "\s-1PEP\s0" 4
.IX Item "PEP"
.IP "Ratio H/L" 4
.IX Item "Ratio H/L"
.IP "Intensity H" 4
.IX Item "Intensity H"
.IP "Intensity L" 4
.IX Item "Intensity L"
.IP "Contaminant" 4
.IX Item "Contaminant"
.IP "Reverse" 4
.IX Item "Reverse"
.PD
.PP
The column names used for storage are defined in the default option
essential_column_names, and can be changed when you call new, or when you call
parseEssentials.  The option is a hash of column names whose values
detmerine whether the column is kept by their truthness... e.g.
.PP
.Vb 5
\&    $o\->parseEssentials(essential_column_names=>(
\&        \*(Aqid\*(Aq  => 1, # kept
\&        \*(AqPEP\*(Aq => 0, # discarded
\&        #foo  => ?, # discarded
\&    ));
.Ve
.PP
If a column doesn't exist, it does not complain!
.PP
The method takes a hash of options.
.PP
options:
.IP "filename \- path of the file to process" 4
.IX Item "filename - path of the file to process"
.PD 0
.IP "separator \- passed to Text::CSV (default is tab)" 4
.IX Item "separator - passed to Text::CSV (default is tab)"
.IP "key_column_name \- change the column keyed on (default is id)" 4
.IX Item "key_column_name - change the column keyed on (default is id)"
.IP "experiment_column_name \- change the column the data are split on" 4
.IX Item "experiment_column_name - change the column the data are split on"
.IP "list_column_names \- change the columns stored as lists" 4
.IX Item "list_column_names - change the columns stored as lists"
.PD
.PP
\fIlist_column_names\fR
.IX Subsection "list_column_names"
.PP
Some columns are the same across all the evidence in a protein group, 
eg, the id is obviously the same, Contaminant and Reverse, Protein IDs, 
and so on.  The default, therefore, is to overwrite the column with
the value seen in an evidence.  \s-1BUT\s0, some columns have a different value
in each evidence, e.g. Ratio H/L or \s-1PEP\s0.  Whatever columns are given in 
list_column_names, which true values, will be appended as lists, so in the
final data, there will be one row per protein and any column bearing multiple
evidences for that protein will be a list.
.PP
If that makes no sense, write to me and I'll try to change it.
.SS "info"
.IX Subsection "info"
used internally, prints to \f(CW$o\fR\->{ih}, which is initially set to an IO::Handle object writing to \s-1STDERR\s0, 
but you might change that if you wanted.  Returns immediately if \f(CW$o\fR\->{quiet} is true, otherwise
prints the remaining contents of \f(CW@_\fR, comma separated, to the handle, followed by a newline.
.SS "experiments"
.IX Subsection "experiments"
Returns a list of the experiments in the data.
.SS "replicated"
.IX Subsection "replicated"
Returns a list of the experiment names without the replicate portion.
.PP
The names are assumed to be Cell.Condition.Replicate, i.e. full-stop (period) separated.
.SS "orthogonals"
.IX Subsection "orthogonals"
Returns a list of sets of orthogonal experiments, that is 3 experiments in which the first has
one condition in common with the other two, but they have nothing in common with each other.
.PP
e.g.   A.X A.Y B.X
.PP
The rationale behind this is that quantitative differences across this set indicate mechanistic
links between, for example, cell line and drug treatment.  If a reponse is seen to a drug, and
a different repsonse is seen in a different cell-type, this system will pick that up.  The
fourth member of the comparison (in the example that would be B.Y) could be anything... and the
interpretation would still be that there is a differential response.
.SS "pairs"
.IX Subsection "pairs"
Returns a list of pairs of replicated experiments (e.g. A.X A.Y, A.X B.X ...)
that represents all possible comparisons.
.SS "ids"
.IX Subsection "ids"
Returns a list of evidence ids in the data.
.SS "sharedIds"
.IX Subsection "sharedIds"
Returns a list containing the ids of those evidences shared between protein groups.
.SS "uniqueIds"
.IX Subsection "uniqueIds"
Returns a list containing the ids of those evidences unique to one protein group.
.SS "saveEssentials(%options)"
.IX Subsection "saveEssentials(%options)"
Save the essential data (quicker to read again in future)
.SS "loadEssentials"
.IX Subsection "loadEssentials"
Load up previously saved essentials
.SS "extractColumnValues"
.IX Subsection "extractColumnValues"
.SS "proteinCount"
.IX Subsection "proteinCount"
.SS "getProteinGroupIds"
.IX Subsection "getProteinGroupIds"
.SS "getLeadingProteins"
.IX Subsection "getLeadingProteins"
.SS "logRatios"
.IX Subsection "logRatios"
Logs ratios (base 2) throughout the dataset, and sets a flag so it can't get logged again.
.PP
Treatment of \*(L"special values\*(R": empty string, <= 0, NaN, and any other non-number are removed
from the data!
.SS "filter"
.IX Subsection "filter"
returns a set of protein records based on filter parameters...
.PP
\fIoptions\fR
.IX Subsection "options"
.IP "experiment \- regular expression to match experiment name" 4
.IX Item "experiment - regular expression to match experiment name"
.PD 0
.IP "proteinGroupId \- regular expression to match protein group id" 4
.IX Item "proteinGroupId - regular expression to match protein group id"
.IP "leadingProteins \- regular expression to match leading protein ids" 4
.IX Item "leadingProteins - regular expression to match leading protein ids"
.IP "notLeadingProteins \- regular expression to not match leading protein ids" 4
.IX Item "notLeadingProteins - regular expression to not match leading protein ids"
.PD
.PP
Returns a filtered object of the same type, with relevant flags set (e.g. whether
data has been logged, etc).
.PP
Warning, intentionally does not perform a deep clone!
.SS "replicateMedian"
.IX Subsection "replicateMedian"
options are passed to filter.
.SS "deviations"
.IX Subsection "deviations"
returns an hashref with the following keys
.IP "n \- the number of items" 4
.IX Item "n - the number of items"
.PD 0
.IP "sd \- the standard deviation (from the mean)" 4
.IX Item "sd - the standard deviation (from the mean)"
.IP "mad \- the median absolute deviation (from the median)" 4
.IX Item "mad - the median absolute deviation (from the median)"
.IP "sd_via_mad \- the standard deviation estimated from the median absolute deviation" 4
.IX Item "sd_via_mad - the standard deviation estimated from the median absolute deviation"
.PD
.SS "mean"
.IX Subsection "mean"
given a list of values, returns the mean
.SS "sd (unbiased standard deviation)"
.IX Subsection "sd (unbiased standard deviation)"
given a list of values, returns a hash with keys mean and sd (standard deviation).
.SS "sum"
.IX Subsection "sum"
given a list of values, returns the sum
.SS "mad"
.IX Subsection "mad"
given a list of values, returns the median absolute deviation
.SS "ttest"
.IX Subsection "ttest"
Given options, experiment1, experiment2 and optional filters,
returns a hash of statistics...
.PP
stats1 and stats2 are hashes of deviations: sd, mad, sd_via_mad, usv, n, values
.PP
ttest is hash of Welch's ttest results: t, df, p
.PP
ttest_mad is like ttest but based on median and median absolute deviateions.
.PP
The p\-values are derived using Welch's Ttest and the t\-distribution function from 
Statistics::Distributions.
.PP
\&\s-1MAD\s0 and medians are much more robust to outliers, which are significant in peptide ratios.
.SS "welchs_ttest"
.IX Subsection "welchs_ttest"
performs Welch's ttest, given mean1, mean2, usv1, usv2, n1 and n2 in a hash.
.PP
e.g.
.PP
.Vb 3
\&    $o\->welchs_ttest( mean1 => 4, mean2 => 3,  # sample mean
\&                      usv1 => 1,  usv2 => 1.1, # unbiased sample variance (returned as usv from $o\->sd
\&                      n1 => 4,    n2=> 7       # number of observations
.Ve
.PP
also performs Welch-Satterthwaite to calculate degrees of freedom (to look up in t\-statistic table)
.PP
Returns hashref containing t and df.
.SS "replicateMedianSubtractions"
.IX Subsection "replicateMedianSubtractions"
Logs data, if not already done, calculates median for each replicate, and subtracts median from each evidence in that replicate.
.SS "median"
.IX Subsection "median"
given a list of numbers, returns the median... assumes all items are numbers!
.SS "experimentMaximumPvalue"
.IX Subsection "experimentMaximumPvalue"
.SS "fullProteinComparison"
.IX Subsection "fullProteinComparison"
Does a full comparison on a particular protein, i.e. compares all pairs of conditions, also does
differential response analysis.  Allows limitation of analysis to proteotypic peptides.
.SS "fullComparison"
.IX Subsection "fullComparison"
Does a full comparison for each protein.  Returns hash of hashes.
.SS "direction"
.IX Subsection "direction"
given two values, returns whether the different between first and second is positive or negative
.PP
returns '+' or '\-'
.SS "directionsDisagree"
.IX Subsection "directionsDisagree"
given two directions, which could be '+', '\-' or '', returns true if one is '+' and the other is '\-'
.SH "AUTHOR"
.IX Header "AUTHOR"
jimi, \f(CW\*(C`<j at 0na.me>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-bio\-maxquant\-evidence\-statistics at rt.cpan.org\*(C'\fR, or through
the web interface at http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Bio\-MaxQuant\-Evidence\-Statistics <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Bio-MaxQuant-Evidence-Statistics>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Bio::MaxQuant::Evidence::Statistics
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker (report bugs here)
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Bio\-MaxQuant\-Evidence\-Statistics <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Bio-MaxQuant-Evidence-Statistics>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/Bio\-MaxQuant\-Evidence\-Statistics <http://annocpan.org/dist/Bio-MaxQuant-Evidence-Statistics>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/Bio\-MaxQuant\-Evidence\-Statistics <http://cpanratings.perl.org/d/Bio-MaxQuant-Evidence-Statistics>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/Bio\-MaxQuant\-Evidence\-Statistics/ <http://search.cpan.org/dist/Bio-MaxQuant-Evidence-Statistics/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2014 jimi.
.PP
This program is released under the following license: artistic2
